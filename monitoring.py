import time
import psutil
import statistics
from collections import deque
from dataclasses import dataclass
from typing import Optional, Dict, Tuple
 
from config import (
    WINDOW_SIZE,
    STD_FACTOR_WARN,
    STD_FACTOR_ALERT,
    MIN_SAMPLES,
)

@dataclass
class MetricStatus:
    """
    The structure upon which the UI is built.
    Text is generated by ui_main.py based on these values.

    """
    name: str
    value: float
    unit: str

    state: str
    z_score: Optional[float]
    mean: Optional[float]
    stdev: Optional[float]
    samples: int

class AnomalyDetector:
    """
    Lightweight, local AI that calculates dynamic baselines and z-scores.
    """

    def __init__(
        self,
        window_size: int = WINDOW_SIZE,
        warn_factor: float = STD_FACTOR_WARN,
        alert_factor: float = STD_FACTOR_ALERT,
        min_samples: int = MIN_SAMPLES,
    ):
        self.window_size = window_size
        self.warn_factor = warn_factor
        self.alert_factor = alert_factor
        self.min_samples = min_samples
        self.history: Dict[str, deque] = {}

    def evaluate(self, name: str, value: float, unit: str) -> MetricStatus:
        dq = self.history.setdefault(name, deque(maxlen=self.window_size))
        dq.append(value)
        samples = len(dq)

        if samples < self.min_samples:
            return MetricStatus(
                name=name,
                value=value,
                unit=unit,
                state="LEARN",
                z_score=None,
                mean=None,
                stdev=None,
                samples=samples,
            )

        mean = statistics.fmean(dq)
        stdev = statistics.pstdev(dq)

        if stdev == 0:
            return MetricStatus(
                name=name,
                value=value,
                unit=unit,
                state="STABLE",
                z_score=0.0,
                mean=mean,
                stdev=stdev,
                samples=samples,
            )

        z = abs(value - mean) / stdev

        if z >= self.alert_factor:
            state = "ALERT"
        elif z >= self.warn_factor:
            state = "WARN"
        else:
            state = "OK"

        return MetricStatus(
            name=name,
            value=value,
            unit=unit,
            state=state,
            z_score=z,
            mean=mean,
            stdev=stdev,
            samples=samples,
        )

class SystemMonitorBackend:
    """
    Provides system metrics in the following format:

    {
        "CPU (%)": (wert, "%"),
        "RAM (%)": (wert, "%"),
        "Disk (%)": (wert, "%"),
        "Net Up (kB/s)": (wert, "kB/s"),
        "Net Down (kB/s)": (wert, "kB/s")
    }
    """

    def __init__(self):
        self._last_net = psutil.net_io_counters()
        self._last_time = time.time()

    def collect(self) -> Dict[str, Tuple[float, str]]:
        metrics: Dict[str, Tuple[float, str]] = {}

        metrics["CPU (%)"] = (psutil.cpu_percent(interval=None), "%")

        metrics["RAM (%)"] = (psutil.virtual_memory().percent, "%")

        try:
            disk = psutil.disk_usage("/")
        except Exception:
            disk = psutil.disk_usage("C:\\")
        metrics["Disk (%)"] = (disk.percent, "%")

        now = time.time()
        net = psutil.net_io_counters()
        elapsed = max(0.1, now - self._last_time)

        up = (net.bytes_sent - self._last_net.bytes_sent) / 1024 / elapsed
        down = (net.bytes_recv - self._last_net.bytes_recv) / 1024 / elapsed

        self._last_net = net
        self._last_time = now

        metrics["Net Up (kB/s)"] = (up, "kB/s")
        metrics["Net Down (kB/s)"] = (down, "kB/s")

        return metrics